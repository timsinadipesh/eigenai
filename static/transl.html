<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>frende - Multimodal Interpreter</title>
    <script src="./js/markdown-it.min.js"></script> 
    <script src="./js/chat-template.js"></script>
    <style>
        /* Translation Settings Modal Styles */
        .translation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .translation-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .translation-content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 750px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }
        
        .translation-content h2 {
            margin: 0 0 1.5rem 0;
            font-size: 1.5rem;
            color: #333;
            text-align: center;
        }
        
        .preset-languages {
            margin-bottom: 1.5rem;
        }
        
        .preset-languages h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            color: #555;
            font-weight: 500;
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.75rem;
        }
        
        .preset-button {
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            text-align: center;
            transition: all 200ms ease;
            font-weight: 500;
        }
        
        .preset-button:hover {
            background: #e9ecef;
            border-color: #0066cc;
        }
        
        .preset-button.active {
            background: #0066cc;
            color: white;
            border-color: #0066cc;
        }
        
        .current-prompt {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .current-prompt h3 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            color: #555;
            font-weight: 500;
        }
        
        .current-prompt p {
            margin: 0;
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }
        
        .translation-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        
        .translation-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 200ms ease;
        }
        
        .translation-btn.primary {
            background: #0066cc;
            color: white;
        }
        
        .translation-btn.primary:hover {
            background: #0056b3;
        }
        
        .translation-btn.secondary {
            background: #6c757d;
            color: white;
        }
        
        .translation-btn.secondary:hover {
            background: #5a6268;
        }
        
        .transcript-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            margin-bottom: 8px;
            display: block;
        }
        
        .translation-label {
            font-size: 12px;
            color: #0066cc;
            font-weight: 500;
            text-transform: uppercase;
            margin-bottom: 8px;
            display: block;
        }

        /* Voice mode button positioned above input field */
        .voice-mode-container {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .voice-mode-button {
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 24px;
            padding: 12px 16px;
            border-radius: 50%;
            transition: all 0.2s ease;
            border: 2px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .voice-mode-button:hover {
            background-color: #e9ecef;
            border-color: #0066cc;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .voice-mode-button.recording {
            background-color: #ffebee;
            border-color: #f44336;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @media (max-width: 768px) {
            .translation-content {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>

    <script>
        // Enhanced Translation Chat App extending ChatTemplate
        class TranslationChatApp extends ChatTemplate {
            constructor() {
                super({
                    modeText: 'Multimodal Interpreter',
                    backUrl: '/',
                    welcomeTitle: 'Multimodal Interpreter',
                    welcomeSubtitle: 'let there be no language barrier',
                    placeholder: 'Type your message in any language...',
                    maxTokens: 32768, // Maximum token length
                    
                    // Enable all features for translation
                    enableTTS: true,
                    enableAttachments: true,
                    enableAudio: true,
                    enableSettings: true,
                    
                    // Settings callback
                    onSettingsClick: () => {
                        this.openTranslationSettings();
                    }
                });
                
                // Translation-specific settings
                this.translationSettings = {
                    activeLanguagePair: 'EN â†” FR', // Default pair
                    languagePairs: {
                        'EN â†” FR': { lang1: 'English', lang2: 'French' },
                        'EN â†” DE': { lang1: 'English', lang2: 'German' },
                        'FR â†” DE': { lang1: 'French', lang2: 'German' }
                    }
                };
                
                // Track if current message has multimedia attachments
                this.hasMultimediaAttachments = false;
                this.currentTranscriptMessage = null;
                this.currentTranslationMessage = null;

                // Voice mode properties
                this.voiceMode = false;
                this.isRecording = false;
                this.recorder = null;
                this.audioChunks = [];
                this.currentAudioBlob = null;
                this.voiceButton = null;
                this.lastTargetLanguage = null;
                this.languageCodes = {
                    'English': 'en-US',
                    'French': 'fr-FR',
                    'German': 'de-DE'
                };
                
                this.loadTranslationSettings();
            }

            // Override initialize to inject translation modal and voice button
            async initialize() {
                await super.initialize();
                this.injectTranslationModal();
                this.handleTransitionData();
                this.setupVoiceButton();
                this.setupVoiceKeyListeners();
            }

            // Setup voice mode button positioned above input field
            setupVoiceButton() {
                // Create container for the voice button
                const voiceContainer = document.createElement('div');
                voiceContainer.className = 'voice-mode-container';
                
                // Create the voice button
                this.voiceButton = document.createElement('button');
                this.voiceButton.innerHTML = 'ðŸŽ¤';
                this.voiceButton.title = 'Toggle Voice Mode';
                this.voiceButton.className = 'voice-mode-button';
                this.voiceButton.onclick = () => this.toggleVoiceMode();
                
                // Add button to container
                voiceContainer.appendChild(this.voiceButton);
                
                // Find the input container and insert the voice container above it
                const inputContainer = this.messageInput.parentNode;
                inputContainer.parentNode.insertBefore(voiceContainer, inputContainer);
            }

            // Setup key listeners for space/pause in voice mode
            setupVoiceKeyListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.voiceMode && !this.isGenerating) {
                        if (e.code === 'Space' || e.code === 'Pause') {
                            e.preventDefault();
                            if (this.isRecording) {
                                this.stopRecording(true);
                            }
                        }
                    }
                });
            }

            // Toggle voice mode
            async toggleVoiceMode() {
                this.voiceMode = !this.voiceMode;
                
                if (this.voiceMode) {
                    this.voiceButton.innerHTML = 'âŒ';
                    this.voiceButton.title = 'Exit Voice Mode';
                    this.messageInput.disabled = true;
                    this.messageInput.placeholder = 'Voice mode active - Press Space to stop recording';
                    await this.startRecording();
                } else {
                    this.voiceButton.innerHTML = 'ðŸŽ¤';
                    this.voiceButton.title = 'Toggle Voice Mode';
                    this.voiceButton.classList.remove('recording');
                    this.stopRecording(false);
                    this.messageInput.disabled = false;
                    this.messageInput.placeholder = 'Type your message in any language...';
                }
            }

            // Start audio recording
            async startRecording() {
                if (this.isRecording) return;
                
                try {
                    this.audioChunks = [];
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    this.recorder = new MediaRecorder(stream);
                    this.recorder.ondataavailable = (e) => {
                        this.audioChunks.push(e.data);
                    };
                    
                    this.recorder.onstop = () => {
                        if (this.audioChunks.length > 0) {
                            this.currentAudioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        }
                        
                        // Stop all tracks to free up microphone
                        stream.getTracks().forEach(track => track.stop());
                        
                        this.recorder = null;
                        this.isRecording = false;
                        this.voiceButton.classList.remove('recording');
                    };
                    
                    this.recorder.start();
                    this.isRecording = true;
                    this.voiceButton.classList.add('recording');
                    
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not access microphone. Please check permissions.');
                }
            }

            // Stop audio recording
            stopRecording(send = true) {
                if (!this.isRecording || !this.recorder) return;
                
                this.recorder.stop();
                
                if (send) {
                    this.recorder.addEventListener('stop', async () => {
                        if (this.currentAudioBlob) {
                            await this.sendAudio();
                        }
                        this.currentAudioBlob = null;
                        this.audioChunks = [];
                    }, { once: true });
                }
            }

            // Send recorded audio
            async sendAudio() {
                if (!this.currentAudioBlob) return;
                
                const file = new File([this.currentAudioBlob], 'voice.webm', { type: 'audio/webm' });
                this.attachedFiles.clear(); // Clear any existing attachments
                this.attachedFiles.set('voice.webm', file);
                this.hasMultimediaAttachments = true;
                
                await this.handleSubmit();
            }

            // Speak text using TTS, waiting for completion
            async speakText(text) {
                if (!('speechSynthesis' in window)) {
                    console.log('TTS not supported');
                    return;
                }

                // Cancel any ongoing speech
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = this.languageCodes[this.lastTargetLanguage] || 'en-US';
                utterance.rate = 0.9; // Slightly slower for better comprehension
                
                return new Promise((resolve) => {
                    utterance.onend = resolve;
                    utterance.onerror = resolve; // Resolve even on error to continue flow
                    window.speechSynthesis.speak(utterance);
                });
            }

            // Generate dynamic translation prompt based on selected language pair
            generateTranslationPrompt() {
                const pair = this.translationSettings.languagePairs[this.translationSettings.activeLanguagePair];
                const { lang1, lang2 } = pair;
                
                return `You are a professional translator specializing in ${lang1} and ${lang2}. Automatically detect if the input is in ${lang1} or ${lang2}, then translate it to the other language. If the input is in ${lang1}, translate to ${lang2}. If the input is in ${lang2}, translate to ${lang1}. Provide contextually appropriate translations that maintain the intended meaning and tone. Preserve any formatting, structure, and special characters in the translation. Output ONLY the final translated text with no explanations, notes, or additional commentary.`;
            }

            // Generate translation prompt for multimedia content
            generateMultimediaTranslationPrompt() {
                const pair = this.translationSettings.languagePairs[this.translationSettings.activeLanguagePair];
                const { lang1, lang2 } = pair;
                
                return `You are a professional translator specializing in ${lang1} and ${lang2}. You will receive audio or image content. First transcribe the content exactly as it appears/sounds, then translate it. Automatically detect if the transcribed content is in ${lang1} or ${lang2}, then translate it to the other language. 

IMPORTANT: You must output your response in the following JSON format:
{
    "source_language": "The detected language of the original content (${lang1} or ${lang2})",
    "transcript": "The exact transcription of the audio or text in the image",
    "target_language": "The target language for translation",
    "translation": "The translation of the transcribed content"
}

Do not include any other text, explanations, or formatting outside of this JSON structure.`;
            }

            // Inject translation settings modal into DOM
            injectTranslationModal() {
                const modalHTML = this.getTranslationModalHTML();
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                this.setupModalEventListeners();
            }

            // Get the translation modal HTML with language pairs
            getTranslationModalHTML() {
                return `
                    <div id="translationModal" class="translation-modal">
                        <div class="translation-content">                    
                            <div class="preset-languages">
                                <h3>Select Language Pair:</h3>
                                <div class="preset-grid">
                                    <button class="preset-button" data-pair="EN â†” FR">English â†” French</button>
                                    <button class="preset-button" data-pair="EN â†” DE">English â†” German</button>
                                    <button class="preset-button" data-pair="FR â†” DE">French â†” German</button>
                                </div>
                            </div>
                            
                            <div class="current-prompt">
                                <h3>Current Translation Behavior:</h3>
                                <p id="promptPreview"></p>
                            </div>
                            
                            <div class="translation-actions">
                                <button class="translation-btn secondary" onclick="closeTranslationSettings()">Cancel</button>
                                <button class="translation-btn primary" onclick="saveTranslationSettings()">Save Settings</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Setup modal event listeners for language pairs
            setupModalEventListeners() {
                // Close modal when clicking outside
                document.addEventListener('click', (e) => {
                    const modal = document.getElementById('translationModal');
                    if (e.target === modal) {
                        this.closeTranslationSettings();
                    }
                });

                // Close modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeTranslationSettings();
                    }
                });
            }

            // Setup language pair button listeners (called when modal opens)
            setupLanguagePairListeners() {
                document.querySelectorAll('.preset-button').forEach(button => {
                    button.addEventListener('click', () => {
                        // Remove active class from all buttons
                        document.querySelectorAll('.preset-button').forEach(btn => btn.classList.remove('active'));
                        
                        // Add active class to clicked button
                        button.classList.add('active');
                        
                        // Update settings
                        this.translationSettings.activeLanguagePair = button.dataset.pair;
                        this.updatePromptPreview();
                    });
                });
            }

            // Update the prompt preview
            updatePromptPreview() {
                const prompt = this.generateTranslationPrompt();
                const promptElement = document.getElementById('promptPreview');
                if (promptElement) {
                    promptElement.textContent = prompt;
                }
            }

            // Open translation settings modal with current selection
            openTranslationSettings() {
                const modal = document.getElementById('translationModal');
                
                // Setup button listeners each time modal opens
                this.setupLanguagePairListeners();
                
                // Set active button based on current settings
                document.querySelectorAll('.preset-button').forEach(button => {
                    if (button.dataset.pair === this.translationSettings.activeLanguagePair) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
                
                this.updatePromptPreview();
                modal.classList.add('active');
            }

            // Close translation settings modal
            closeTranslationSettings() {
                const modal = document.getElementById('translationModal');
                modal.classList.remove('active');
            }

            // Save translation settings
            saveTranslationSettings() {
                // Save to localStorage
                localStorage.setItem('translationSettings', JSON.stringify(this.translationSettings));
                this.closeTranslationSettings();
            }

            // Load translation settings from localStorage
            loadTranslationSettings() {
                try {
                    const saved = localStorage.getItem('translationSettings');
                    if (saved) {
                        this.translationSettings = { ...this.translationSettings, ...JSON.parse(saved) };
                    }
                } catch (error) {
                    console.error('Error loading translation settings:', error);
                }
            }

            // New method to read file as text (async)
            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            // Override processMessage to use translation prompt
            processMessage(message) {
                // Use different prompt for multimedia vs text-only
                const translationPrompt = this.hasMultimediaAttachments 
                    ? this.generateMultimediaTranslationPrompt() 
                    : this.generateTranslationPrompt();
                
                if (!message.trim()) {
                    return translationPrompt;
                }
                
                return `${translationPrompt}\n\nPlease translate: ${message}`;
            }

            // Override handleStreamingGeneration to handle JSON responses for multimedia
            async handleStreamingGeneration(formData, messageContent, cursor) {
                this.abortController = new AbortController();
                
                const response = await fetch(this.config.generateEndpoint, {
                    method: 'POST',
                    body: formData,
                    signal: this.abortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullResponse = '';
                let jsonBuffer = '';
                let isCollectingJson = this.hasMultimediaAttachments;
                let jsonParsed = false;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                if (data.error) throw new Error(data.error);
                                
                                if (!data.finished && data.token) {
                                    if (isCollectingJson && !jsonParsed) {
                                        jsonBuffer += data.token;
                                        fullResponse += data.token;
                                        
                                        // Try to extract and stream partial content
                                        if (jsonBuffer.includes('{')) {
                                            try {
                                                // Look for partial JSON fields as they're being generated
                                                const transcriptMatch = jsonBuffer.match(/"transcript":\s*"([^"]*(?:\\.[^"]*)*)"?/);
                                                const translationMatch = jsonBuffer.match(/"translation":\s*"([^"]*(?:\\.[^"]*)*)"?/);
                                                const sourceLanguageMatch = jsonBuffer.match(/"source_language":\s*"([^"]*)"?/);
                                                const targetLanguageMatch = jsonBuffer.match(/"target_language":\s*"([^"]*)"?/);
                                                
                                                // Create transcript message if we have source language and some transcript content
                                                if (!this.currentTranscriptMessage && sourceLanguageMatch && transcriptMatch) {
                                                    // Remove temporary streaming message
                                                    if (this.currentStreamingMessage && this.currentStreamingMessage.parentNode) {
                                                        this.currentStreamingMessage.remove();
                                                        this.currentStreamingMessage = null;
                                                    }
                                                    
                                                    this.currentTranscriptMessage = this.addMessage('assistant', '');
                                                    const transcriptContent = this.currentTranscriptMessage.querySelector('.message-content');
                                                    const transcriptLabel = document.createElement('span');
                                                    transcriptLabel.className = 'transcript-label';
                                                    transcriptLabel.textContent = `Transcript (${sourceLanguageMatch[1]})`;
                                                    transcriptContent.appendChild(transcriptLabel);
                                                    
                                                    const transcriptDiv = document.createElement('div');
                                                    transcriptDiv.className = 'streaming-transcript';
                                                    transcriptContent.appendChild(transcriptDiv);
                                                    
                                                    const transcriptCursor = document.createElement('span');
                                                    transcriptCursor.className = 'streaming-cursor';
                                                    transcriptContent.appendChild(transcriptCursor);
                                                }
                                                
                                                // Update transcript content
                                                if (this.currentTranscriptMessage && transcriptMatch) {
                                                    const transcriptDiv = this.currentTranscriptMessage.querySelector('.streaming-transcript');
                                                    if (transcriptDiv) {
                                                        // Unescape JSON string and render
                                                        const unescapedTranscript = transcriptMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
                                                        transcriptDiv.innerHTML = this.md.render(unescapedTranscript);
                                                    }
                                                }
                                                
                                                // Create translation message if we have target language and some translation content
                                                if (!this.currentTranslationMessage && targetLanguageMatch && translationMatch) {
                                                    this.currentTranslationMessage = this.addMessage('assistant', '');
                                                    const translationContent = this.currentTranslationMessage.querySelector('.message-content');
                                                    const translationLabel = document.createElement('span');
                                                    translationLabel.className = 'translation-label';
                                                    translationLabel.textContent = `Translation (${targetLanguageMatch[1]})`;
                                                    translationContent.appendChild(translationLabel);
                                                    
                                                    const translationDiv = document.createElement('div');
                                                    translationDiv.className = 'streaming-translation';
                                                    translationContent.appendChild(translationDiv);
                                                    
                                                    const translationCursor = document.createElement('span');
                                                    translationCursor.className = 'streaming-cursor';
                                                    translationContent.appendChild(translationCursor);
                                                }
                                                
                                                // Update translation content
                                                if (this.currentTranslationMessage && translationMatch) {
                                                    const translationDiv = this.currentTranslationMessage.querySelector('.streaming-translation');
                                                    if (translationDiv) {
                                                        // Unescape JSON string and render
                                                        const unescapedTranslation = translationMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
                                                        translationDiv.innerHTML = this.md.render(unescapedTranslation);
                                                    }
                                                }
                                                
                                                // Check if JSON is complete for final cleanup
                                                if (jsonBuffer.includes('}') && transcriptMatch && translationMatch) {
                                                    const startIndex = jsonBuffer.indexOf('{');
                                                    const endIndex = jsonBuffer.lastIndexOf('}');
                                                    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                                                        try {
                                                            const jsonStr = jsonBuffer.substring(startIndex, endIndex + 1);
                                                            const jsonResponse = JSON.parse(jsonStr);
                                                            
                                                            if (jsonResponse.transcript && jsonResponse.translation) {
                                                                jsonParsed = true;
                                                                
                                                                // Save target language for TTS
                                                                this.lastTargetLanguage = jsonResponse.target_language;
                                                                
                                                                // Remove cursors and add final actions
                                                                if (this.currentTranscriptMessage) {
                                                                    const transcriptCursor = this.currentTranscriptMessage.querySelector('.streaming-cursor');
                                                                    if (transcriptCursor) transcriptCursor.remove();
                                                                    this.addMessageActions(this.currentTranscriptMessage, jsonResponse.transcript);
                                                                }
                                                                
                                                                if (this.currentTranslationMessage) {
                                                                    const translationCursor = this.currentTranslationMessage.querySelector('.streaming-cursor');
                                                                    if (translationCursor) translationCursor.remove();
                                                                    this.addMessageActions(this.currentTranslationMessage, jsonResponse.translation);
                                                                }
                                                                
                                                                fullResponse = jsonResponse.translation;
                                                            }
                                                        } catch (e) {
                                                            // JSON still not complete
                                                        }
                                                    }
                                                }
                                                
                                                this.scrollToBottom();
                                                
                                            } catch (e) {
                                                // Continue collecting tokens
                                            }
                                        }
                                    } else if (!isCollectingJson) {
                                        // Regular text-only translation
                                        fullResponse += data.token;
                                        const textDiv = document.createElement('div');
                                        textDiv.innerHTML = this.md.render(fullResponse);
                                        
                                        messageContent.innerHTML = '';
                                        messageContent.appendChild(textDiv);
                                        messageContent.appendChild(cursor);
                                        this.scrollToBottom();
                                    }
                                }
                                
                                if (data.finished) {
                                    return fullResponse; // Return full response on success
                                }
                            } catch (parseError) {
                                console.error('Failed to parse SSE data:', parseError);
                            }
                        }
                    }
                }
                return fullResponse; // Return whatever was streamed if loop finishes unexpectedly
            }

            // Override handleSubmit to use processMessage
            async handleSubmit() {
                if (this.isGenerating) {
                    this.stopGeneration();
                    return;
                }
                
                let message = this.messageInput.value.trim();
                if (!message && this.attachedFiles.size === 0) return;

                // Process attachments: build full text (message + text file contents) and set multimedia flag
                let fullText = message;
                const textContents = [];
                this.hasMultimediaAttachments = false;

                for (const [name, file] of this.attachedFiles) {
                    if (file.type.startsWith('image/') || file.type.startsWith('audio/')) {
                        this.hasMultimediaAttachments = true;
                    } else if (file.type.startsWith('text/') || file.name.toLowerCase().endsWith('.md')) {
                        // Read as text file (e.g., .md support)
                        try {
                            const content = await this.readFileAsText(file);
                            textContents.push(`File: ${file.name}\nContent:\n${content}\n`);
                        } catch (e) {
                            console.error(`Error reading text file ${file.name}:`, e);
                            // Skip silently; could add UI error if needed
                        }
                    } else {
                        console.warn(`Unsupported file type for ${file.name}; skipping.`);
                        // Could add UI feedback here if desired
                    }
                }

                // Append text file contents to fullText
                if (textContents.length > 0) {
                    fullText += '\n\n' + textContents.join('\n\n');
                }

                // Process the full message with translation prompt
                const processedMessage = this.processMessage(fullText);

                this.isGenerating = true;
                this.updateSendButton();

                const messageAttachments = new Map(this.attachedFiles);
                
                // Add user message only if not in voice mode
                if (!this.voiceMode) {
                    this.addMessage('user', message, messageAttachments); // Show original message to user
                }
                
                this.messageInput.value = '';
                this.autoResizeTextarea();
                this.clearAttachments();
                
                // For multimedia, we'll create messages during streaming
                // For text-only, create the message now
                if (!this.hasMultimediaAttachments) {
                    this.currentStreamingMessage = this.addMessage('assistant', '');
                    const messageContent = this.currentStreamingMessage.querySelector('.message-content');
                    const cursor = document.createElement('span');
                    cursor.className = 'streaming-cursor';
                    messageContent.appendChild(cursor);
                    
                    try {
                        const formData = new FormData();
                        formData.append('text', processedMessage); // Send processed message to API
                        formData.append('max_tokens', this.config.maxTokens.toString());
                        
                        messageAttachments.forEach((file, name) => {
                            if (file.type.startsWith('image/')) {
                                formData.append('image', file);
                            } else if (file.type.startsWith('audio/')) {
                                formData.append('audio', file);
                            }
                        });

                        const fullResponse = await this.handleStreamingGeneration(formData, messageContent, cursor);
                        
                        // Final UI update on success
                        cursor.remove();
                        this.addMessageActions(this.currentStreamingMessage, fullResponse);

                        // In voice mode, speak the translation and restart recording
                        if (this.voiceMode && fullResponse.trim()) {
                            await this.speakText(fullResponse);
                            // Restart recording after TTS finishes
                            if (this.voiceMode) { // Check again in case user exited voice mode during TTS
                                await this.startRecording();
                            }
                        }

                    } catch (error) {
                        // Check if we still have a valid streaming message before accessing it
                        if (this.currentStreamingMessage) {
                            const messageContent = this.currentStreamingMessage.querySelector('.message-content');
                            if (messageContent) {
                                cursor.remove(); // Remove cursor
                                
                                if (error.name === 'AbortError') {
                                    console.log('Generation stopped by user.');
                                    const stoppedDiv = document.createElement('div');
                                    stoppedDiv.style.cssText = 'color: #666; font-style: italic; margin-top: 8px; font-size: 14px;';
                                    stoppedDiv.textContent = '[Generation stopped]';
                                    messageContent.appendChild(stoppedDiv);
                                    
                                    const textContent = messageContent.textContent.replace('[Generation stopped]', '').trim();
                                    if (textContent) {
                                        this.addMessageActions(this.currentStreamingMessage, textContent);
                                    }
                                } else {
                                    messageContent.innerHTML = `<div style="color: #dc2626;">Error: ${error.message}</div>`;
                                }
                            }
                        }
                    } finally {
                        this.isGenerating = false;
                        this.isStreaming = false;
                        this.updateSendButton();
                        this.abortController = null;
                        this.currentStreamingMessage = null;
                        this.hasMultimediaAttachments = false; // Reset the flag
                    }
                } else {
                    // For multimedia, create a temporary message with cursor
                    this.currentStreamingMessage = this.addMessage('assistant', '');
                    const messageContent = this.currentStreamingMessage.querySelector('.message-content');
                    const cursor = document.createElement('span');
                    cursor.className = 'streaming-cursor';
                    messageContent.appendChild(cursor);
                    
                    try {
                        const formData = new FormData();
                        formData.append('text', processedMessage); // Send processed message to API
                        formData.append('max_tokens', this.config.maxTokens.toString());
                        
                        messageAttachments.forEach((file, name) => {
                            if (file.type.startsWith('image/')) {
                                formData.append('image', file);
                            } else if (file.type.startsWith('audio/')) {
                                formData.append('audio', file);
                            }
                        });

                        const fullResponse = await this.handleStreamingGeneration(formData, messageContent, cursor);
                        
                        // Remove the temporary message since we created separate transcript and translation messages
                        if (this.currentStreamingMessage && this.currentStreamingMessage.parentNode) {
                            this.currentStreamingMessage.remove();
                        }

                        // In voice mode, speak the translation and restart recording
                        if (this.voiceMode && fullResponse.trim()) {
                            await this.speakText(fullResponse);
                            // Restart recording after TTS finishes
                            if (this.voiceMode) { // Check again in case user exited voice mode during TTS
                                await this.startRecording();
                            }
                        }

                    } catch (error) {
                        // Handle errors for multimedia
                        if (this.currentStreamingMessage) {
                            const messageContent = this.currentStreamingMessage.querySelector('.message-content');
                            if (messageContent) {
                                cursor.remove(); // Remove cursor
                                
                                if (error.name === 'AbortError') {
                                    console.log('Generation stopped by user.');
                                    messageContent.innerHTML = '<div style="color: #666; font-style: italic;">[Generation stopped]</div>';
                                } else {
                                    messageContent.innerHTML = `<div style="color: #dc2626;">Error: ${error.message}</div>`;
                                }
                            }
                        }
                    } finally {
                        this.isGenerating = false;
                        this.isStreaming = false;
                        this.updateSendButton();
                        this.abortController = null;
                        this.currentStreamingMessage = null;
                        this.currentTranscriptMessage = null;
                        this.currentTranslationMessage = null;
                        this.hasMultimediaAttachments = false; // Reset the flag
                    }
                }
            }

            // Handle transition data from landing page
            handleTransitionData() {
                const transitionData = sessionStorage.getItem('chatTransition');
                if (transitionData) {
                    try {
                        const data = JSON.parse(transitionData);
                        
                        // Handle message if present
                        if (data.message) {
                            this.messageInput.value = data.message;
                            this.autoResizeTextarea();
                        }
                        
                        // Handle files if present
                        if (data.files && data.files.length > 0) {
                            data.files.forEach(([name, fileData]) => {
                                fetch(fileData.data)
                                    .then(res => res.blob())
                                    .then(blob => {
                                        const file = new File([blob], fileData.name, { type: fileData.type });
                                        this.attachedFiles.set(name, file);
                                        this.renderAttachments();
                                        this.updateSendButton();
                                    });
                            });
                        }
                        
                        // Auto-send if from direct mode
                        if (data.mode === 'direct' && (data.message || (data.files && data.files.length > 0))) {
                            setTimeout(() => {
                                if (this.messageInput.value.trim() || this.attachedFiles.size > 0) {
                                    this.handleSubmit();
                                }
                            }, 500);
                        }
                        
                        // Clear transition data
                        sessionStorage.removeItem('chatTransition');
                        
                    } catch (e) {
                        console.error('Error parsing transition data:', e);
                        sessionStorage.removeItem('chatTransition');
                    }
                }
            }
        }

        let translationApp;

        // Global functions for modal
        function closeTranslationSettings() {
            if (translationApp) {
                translationApp.closeTranslationSettings();
            }
        }

        function saveTranslationSettings() {
            if (translationApp) {
                translationApp.saveTranslationSettings();
            }
        }

        // Initialize the translation app when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            translationApp = new TranslationChatApp();
            await translationApp.initialize();
            translationApp.openTranslationSettings();
        });
    </script>
</body>
</html>